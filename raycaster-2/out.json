{
  "toc": [
    "assets_manager.py",
    "config.py",
    "entity.py",
    "main.py",
    "map.py",
    "network.py",
    "player.py",
    "remote_player.py",
    "renderer.py",
    "server.py",
    "sprite.py"
  ],
  "files": [
    {
      "filename": "assets_manager.py",
      "metadata": {
        "lines": 141,
        "modified": "2025-04-29T20:31:49.923378"
      },
      "content": "# assets_manager.py\nimport pyray as pr\nimport os\nimport config\nfrom typing import Dict, List, Optional\n\nclass AssetsManager:\n    def __init__(self):\n        self.wall_textures: Dict[int, pr.Texture2D] = {}\n        self.sprite_textures: Dict[str, List[pr.Texture2D]] = {} # e.g., {\"WinterGuard\": [tex1, tex2...]}\n        self.error_texture: Optional[pr.Texture2D] = None\n        self._create_error_texture()\n\n    def _create_error_texture(self):\n        \"\"\"Creates a fallback texture for missing assets.\"\"\"\n        img = pr.gen_image_checked(config.TEXTURE_SIZE, config.TEXTURE_SIZE, 16, 16, pr.PINK, pr.BLACK)\n        self.error_texture = pr.load_texture_from_image(img)\n        pr.unload_image(img)\n        print(\"Generated error texture.\")\n\n    def load_assets(self, assets_dir: str = \"assets\"):\n        \"\"\"Loads all wall and sprite textures.\"\"\"\n        print(\"Loading assets...\")\n        self._load_wall_textures(os.path.join(assets_dir, \"textures\"))\n        self._load_sprites(os.path.join(assets_dir, \"sprites\"))\n        print(\"Asset loading complete.\")\n\n    def _load_wall_textures(self, textures_path: str):\n        print(f\" Looking for wall textures in: {textures_path}\")\n        if not os.path.isdir(textures_path):\n            print(f\" Warning: Wall texture directory not found: {textures_path}\")\n            return\n\n        for filename in os.listdir(textures_path):\n            if filename.startswith(\"wall_\") and filename.endswith(\".png\"):\n                try:\n                    wall_id_str = filename.split('_')[1].split('.')[0]\n                    wall_id = int(wall_id_str)\n                    filepath = os.path.join(textures_path, filename)\n                    texture = pr.load_texture(filepath)\n                    if texture.id == 0: # Check if loading failed\n                         print(f\" Warning: Failed to load texture: {filepath}. Using error texture.\")\n                         self.wall_textures[wall_id] = self.error_texture\n                    else:\n                         self.wall_textures[wall_id] = texture\n                         pr.gen_texture_mipmaps(self.wall_textures[wall_id])\n                         pr.set_texture_filter(self.wall_textures[wall_id], pr.TextureFilter.TEXTURE_FILTER_TRILINEAR)\n                         print(f\"  Loaded wall texture ID {wall_id}: {filename}\")\n                except (IndexError, ValueError) as e:\n                    print(f\" Warning: Could not parse wall ID from filename: {filename} ({e})\")\n                except Exception as e:\n                     print(f\" Error loading texture {filename}: {e}\")\n                     # Assign error texture if ID was parsed but loading failed later\n                     if 'wall_id' in locals():\n                         self.wall_textures[wall_id] = self.error_texture\n\n        if not self.wall_textures:\n            print(\" Warning: No wall textures were loaded.\")\n\n    def _load_sprites(self, sprites_path: str):\n        print(f\" Looking for sprites in: {sprites_path}\")\n        if not os.path.isdir(sprites_path):\n            print(f\" Warning: Sprites directory not found: {sprites_path}\")\n            return\n\n        sprite_files = {} # Group files by sprite name (e.g., \"WinterGuard\")\n        for filename in os.listdir(sprites_path):\n            if filename.endswith(\".png\"):\n                parts = filename.split('_')\n                if len(parts) >= 2:\n                    sprite_name = parts[0]\n                    try:\n                        sprite_index = int(parts[-1].split('.')[0]) # Get the number at the end\n                        if sprite_name not in sprite_files:\n                            sprite_files[sprite_name] = []\n                        sprite_files[sprite_name].append((sprite_index, os.path.join(sprites_path, filename)))\n                    except ValueError:\n                        print(f\" Warning: Could not parse sprite index from filename: {filename}\")\n                else:\n                     print(f\" Warning: Skipping sprite file with unexpected name format: {filename}\")\n\n\n        for sprite_name, files in sprite_files.items():\n            # Sort files by index to ensure correct order\n            files.sort(key=lambda item: item[0])\n\n            self.sprite_textures[sprite_name] = []\n            max_index = files[-1][0] if files else 0\n            # Ensure list is large enough, fill potentially missing ones with error texture\n            self.sprite_textures[sprite_name] = [self.error_texture] * (max_index + 1)\n\n            print(f\"  Loading sprite '{sprite_name}'...\")\n            for index, filepath in files:\n                texture = pr.load_texture(filepath)\n                if texture.id == 0:\n                    print(f\"   Warning: Failed to load sprite index {index}: {filepath}. Using error texture.\")\n                    # Already pre-filled with error texture\n                else:\n                    self.sprite_textures[sprite_name][index] = texture\n                    pr.gen_texture_mipmaps(self.sprite_textures[sprite_name][index])\n                    pr.set_texture_filter(self.sprite_textures[sprite_name][index], pr.TextureFilter.TEXTURE_FILTER_TRILINEAR)\n                    print(f\"   Loaded sprite index {index}: {os.path.basename(filepath)}\")\n\n        if not self.sprite_textures:\n             print(\" Warning: No sprites were loaded.\")\n\n\n    def get_wall_texture(self, wall_id: int) -> pr.Texture2D:\n        \"\"\"Gets a wall texture by ID, returns error texture if not found.\"\"\"\n        return self.wall_textures.get(wall_id, self.error_texture)\n\n    def get_sprite_texture(self, sprite_name: str, index: int) -> pr.Texture2D:\n        \"\"\"Gets a specific sprite texture, returns error texture if not found.\"\"\"\n        if sprite_name in self.sprite_textures:\n            textures = self.sprite_textures[sprite_name]\n            # Check index bounds explicitly, using 0-based index\n            if 0 <= index < len(textures):\n                return textures[index]\n            else:\n                 print(f\"Warning: Sprite index {index} out of bounds for '{sprite_name}' (max: {len(textures)-1}).\")\n                 return self.error_texture # Out of bounds\n        print(f\"Warning: Sprite name '{sprite_name}' not found.\")\n        return self.error_texture # Sprite name not found\n\n    def unload_assets(self):\n        \"\"\"Unloads all loaded textures.\"\"\"\n        print(\"Unloading assets...\")\n        for texture in self.wall_textures.values():\n            if texture and texture.id != self.error_texture.id: # Avoid unloading the error texture multiple times\n                pr.unload_texture(texture)\n        for sprite_name in self.sprite_textures:\n             for texture in self.sprite_textures[sprite_name]:\n                 if texture and texture.id != self.error_texture.id:\n                     pr.unload_texture(texture)\n\n        if self.error_texture:\n             pr.unload_texture(self.error_texture) # Unload the error texture once\n\n        self.wall_textures.clear()\n        self.sprite_textures.clear()\n        print(\"Assets unloaded.\")"
    },
    {
      "filename": "config.py",
      "metadata": {
        "lines": 56,
        "modified": "2025-04-29T20:46:03.788347"
      },
      "content": "# config.py\nimport math\nimport pyray as pr\n\n# Screen Dimensions\nSCREEN_WIDTH = 1280\nSCREEN_HEIGHT = 720\nTARGET_FPS = 60\n\n# Player Settings\nPLAYER_START_X = 3.5\nPLAYER_START_Y = 3.5\nPLAYER_START_ANGLE = 0.0 # Radians\nPLAYER_MOVE_SPEED = 2.5  # Units per second\nPLAYER_RUN_MULTIPLIER = 1.8\nPLAYER_ROTATION_SPEED = 2.0 # Radians per second\nPLAYER_FOV = math.radians(60) # Field of View in radians\nPLAYER_HEALTH_START = 100\n\n# Rendering Settings\nNUM_RAYS = SCREEN_WIDTH // 2 # Number of rays to cast (adjust for performance/quality)\nMAX_RENDER_DEPTH = 20.0    # Maximum distance to render walls/sprites\nTEXTURE_SIZE = 64         # Assuming square textures (width & height)\nRENDER_SCALE_FACTOR = 2   # For drawing wall slices wider than 1 pixel\n\n# Map Settings\nMAP_TILE_SIZE = 1.0 # Size of one map tile in world units\n\n# Network Settings\n# Replace with your actual server IP and Port\nSERVER_IP = \"127.0.0.1\" # Loopback for local testing\nSERVER_PORT = 5555\nNETWORK_UPDATE_RATE = 1 / 20 # Send updates to server 20 times per second\nSOCKET_TIMEOUT = 0.01 # Short timeout for non-blocking receive\n\n# Sprite/Asset Settings\nSPRITE_SCALE = 0.7 # General scaling for sprites in the world\n\n# Colors\nCOLOR_FLOOR = pr.Color(50, 50, 50, 255)    # Dark Gray\nCOLOR_CEILING = pr.Color(100, 100, 100, 255) # Lighter Gray\nCOLOR_DEBUG_RAY = pr.Color(255, 0, 0, 100)   # Red for debug\nCOLOR_DEBUG_MAP = pr.Color(0, 0, 255, 150)   # Blue for debug map\n\n# Sprite ID mapping for WinterGuard (example)\n# This helps translate server state to texture index\nSPRITE_WINTERGUARD_IDLE_START = 1\nSPRITE_WINTERGUARD_WALK_START = 9\nSPRITE_WINTERGUARD_RUN_START = 17\nSPRITE_DIRECTIONS = 8 # 8 directions for each state\n\n# Game States\nSTATE_MENU = 0\nSTATE_PLAYING = 1\nSTATE_GAME_OVER = 2\nSTATE_CONNECTING = 3"
    },
    {
      "filename": "entity.py",
      "metadata": {
        "lines": 35,
        "modified": "2025-04-29T20:53:42.001529"
      },
      "content": "# entity.py\n# Representation for static/collectible entities like keys, chests\nfrom typing import Tuple\nimport config\n\nclass Entity:\n    def __init__(self, entity_id: str, data: dict):\n        self.id = entity_id\n        self.x: float = 0.0\n        self.y: float = 0.0\n        self.type: str = \"Unknown\" # e.g., \"Key\", \"Chest\", \"HealthPack\"\n        self.texture_name: str = \"DefaultEntity\" # Asset name for this entity\n        self.texture_index: int = 0 # Frame/variant if needed\n        self.is_active: bool = True # e.g., set to False when picked up\n        self.scale: float = config.SPRITE_SCALE * 0.8 # Slightly smaller maybe?\n\n        self.update_from_server(data)\n\n    def update_from_server(self, data: dict):\n        \"\"\"Updates entity state from server data.\"\"\"\n        # Usually only position and active status change\n        self.x = data.get(\"x\", self.x)\n        self.y = data.get(\"y\", self.y)\n        self.type = data.get(\"type\", self.type)\n        self.texture_name = data.get(\"texture_name\", self.texture_name)\n        self.texture_index = data.get(\"texture_index\", self.texture_index)\n        self.is_active = data.get(\"is_active\", self.is_active)\n        self.scale = data.get(\"scale\", self.scale)\n\n    def get_pos_tuple(self) -> Tuple[float, float]:\n        return (self.x, self.y)\n\n    def should_draw(self) -> bool:\n        \"\"\"Determines if the entity should be drawn (e.g., is active).\"\"\"\n        return self.is_active"
    },
    {
      "filename": "main.py",
      "metadata": {
        "lines": 315,
        "modified": "2025-04-29T20:38:45.183131"
      },
      "content": "# main.py\nfrom typing import Optional\nimport pyray as pr\nimport time\nimport config\n\n# Import game components\nfrom assets_manager import AssetsManager\nfrom map import GameMap\nfrom player import Player\nfrom remote_player import RemotePlayer # Only the class needed here\nfrom sprite import Sprite\nfrom entity import Entity\nfrom network import NetworkClient\nfrom renderer import Renderer\n\nclass Game:\n    def __init__(self):\n        # Initialization\n        pr.init_window(config.SCREEN_WIDTH, config.SCREEN_HEIGHT, \"Python Raycaster Multiplayer\")\n        pr.set_target_fps(config.TARGET_FPS)\n        # pr.hide_cursor() # Optional: Hide cursor during gameplay\n\n        self.assets_manager = AssetsManager()\n        self.game_map = GameMap()\n        self.player = Player(config.PLAYER_START_X, config.PLAYER_START_Y, config.PLAYER_START_ANGLE)\n        self.network_client = NetworkClient()\n        self.renderer = Renderer(self.assets_manager)\n\n        # Game State Management\n        self.remote_players: dict[str, RemotePlayer] = {}\n        self.sprites: dict[str, Sprite] = {}\n        self.entities: dict[str, Entity] = {}\n        self.game_state = config.STATE_CONNECTING # Start in connecting state\n        self.client_id: Optional[str] = None # Assigned by server upon connection\n\n        # Timing for network updates\n        self.last_network_send_time = 0.0\n\n    def load_content(self):\n        \"\"\"Load game assets.\"\"\"\n        self.assets_manager.load_assets()\n        # TODO: Load map data from server or file if needed\n        # self.game_map.load_from_file(\"map.txt\")\n\n    def unload_content(self):\n        \"\"\"Unload game assets.\"\"\"\n        self.assets_manager.unload_assets()\n\n    def run(self):\n        \"\"\"Main game loop.\"\"\"\n        self.load_content()\n\n        while not pr.window_should_close():\n            # Get frame time for physics/movement calculations\n            delta_time = pr.get_frame_time()\n\n            # --- Update ---\n            self.update(delta_time)\n\n            # --- Draw ---\n            self.renderer.draw_frame(self.player, self.game_map, self.remote_players, self.sprites, self.entities)\n\n        self.shutdown()\n\n    def update(self, delta_time: float):\n        \"\"\"Handles all game logic updates for a frame.\"\"\"\n\n        # Handle Network Updates (Receive)\n        if self.network_client.connected:\n            server_messages = self.network_client.receive_data()\n            self.process_server_messages(server_messages)\n        elif self.game_state != config.STATE_CONNECTING:\n            # If disconnected unexpectedly, maybe try reconnecting or go to a menu\n            print(\"Connection lost. Attempting to reconnect...\")\n            self.game_state = config.STATE_CONNECTING\n\n\n        # Update based on Game State\n        if self.game_state == config.STATE_CONNECTING:\n            if self.network_client.connect():\n                 # Connection successful, wait for server handshake (e.g., client ID assignment)\n                 # For now, just switch to playing - server needs to send initial state\n                 print(\"Connected. Waiting for server state...\")\n                 # Assume server will send initial state shortly\n                 self.game_state = config.STATE_PLAYING # Or a STATE_LOADING if needed\n            else:\n                # Failed connection, maybe show an error message, wait and retry?\n                # For now, we just keep trying in the loop. Add delay?\n                 time.sleep(1.0) # Wait before retrying\n\n        elif self.game_state == config.STATE_PLAYING:\n            # Update local player (input and movement)\n            self.player.update(delta_time, self.game_map)\n\n            # Update other game logic if needed (e.g., local effects)\n\n            # Handle Network Updates (Send)\n            current_time = time.time()\n            if self.network_client.connected and (current_time - self.last_network_send_time >= config.NETWORK_UPDATE_RATE):\n                player_state = self.player.get_state_dict()\n                self.network_client.send_data({\n                    \"type\": \"player_update\",\n                    \"payload\": player_state\n                })\n                self.last_network_send_time = current_time\n                # Reset one-shot flags after sending\n                if self.player.is_shooting: self.player.is_shooting = False\n\n\n        elif self.game_state == config.STATE_GAME_OVER:\n            # Handle game over logic (e.g., wait for input to restart/quit)\n            if pr.is_key_pressed(pr.KeyboardKey.KEY_ENTER):\n                self.reset_game() # Example reset function\n\n        # --- Check for connection loss outside receive block ---\n        if not self.network_client.connected and self.game_state == config.STATE_PLAYING:\n             print(\"Lost connection during gameplay.\")\n             self.game_state = config.STATE_CONNECTING # Try to reconnect\n\n\n    def process_server_messages(self, messages: list[dict[str, any]]):\n        \"\"\"Processes messages received from the server.\"\"\"\n        for msg in messages:\n            msg_type = msg.get(\"type\")\n            payload = msg.get(\"payload\")\n\n            if not msg_type or not payload:\n                print(f\"Warning: Received malformed message: {msg}\")\n                continue\n\n            # print(f\"Processing server message: {msg_type}\") # Debug\n\n            if msg_type == \"handshake_ack\":\n                # Server acknowledges connection and assigns an ID\n                self.client_id = payload.get(\"client_id\")\n                print(f\"Handshake complete. Client ID: {self.client_id}\")\n                # Possibly request full game state here or server sends it automatically\n\n            elif msg_type == \"game_state_full\":\n                # Initial full state or major update\n                self.update_full_game_state(payload)\n\n            elif msg_type == \"game_state_update\":\n                # Incremental update\n                self.update_incremental_game_state(payload)\n\n            elif msg_type == \"player_disconnect\":\n                # Another player disconnected\n                player_id = payload.get(\"client_id\")\n                if player_id and player_id in self.remote_players:\n                    print(f\"Player {player_id} disconnected.\")\n                    del self.remote_players[player_id]\n\n            elif msg_type == \"entity_update\": # Example for single entity change\n                 entity_id = payload.get(\"id\")\n                 if entity_id and entity_id in self.entities:\n                     self.entities[entity_id].update_from_server(payload)\n                 else: # New entity perhaps?\n                     self.entities[entity_id] = Entity(entity_id, payload)\n\n\n            elif msg_type == \"map_update\":\n                 self.game_map.update_map(payload.get(\"grid\", []))\n\n            elif msg_type == \"player_state_correction\":\n                 # Server corrects local player state (e.g. health, death, possibly pos)\n                 self.player.apply_server_update(payload)\n                 if self.player.is_dead and self.game_state != config.STATE_GAME_OVER:\n                      print(\"Player died.\")\n                      self.game_state = config.STATE_GAME_OVER\n\n\n            # Add more message types as needed (chat, item pickups, etc.)\n            else:\n                print(f\"Warning: Received unknown message type: {msg_type}\")\n\n    def update_full_game_state(self, state: dict[str, any]):\n        \"\"\"Applies a complete game state snapshot from the server.\"\"\"\n        print(\"Applying full game state from server...\")\n        # Update map (optional, if map can change)\n        if \"map\" in state and \"grid\" in state[\"map\"]:\n            self.game_map.update_map(state[\"map\"][\"grid\"])\n\n        # Update local player's authoritative state (health, maybe position on spawn)\n        if self.client_id and self.client_id in state.get(\"players\", {}):\n            self.player.apply_server_update(state[\"players\"][self.client_id])\n\n        # Update remote players\n        remote_players_data = state.get(\"players\", {})\n        current_remote_ids = set(self.remote_players.keys())\n        server_remote_ids = set(remote_players_data.keys()) - {self.client_id} # Exclude self\n\n        # Add/Update players present in server state\n        for pid in server_remote_ids:\n            if pid in self.remote_players:\n                self.remote_players[pid].update_from_server(remote_players_data[pid])\n            else:\n                print(f\" Adding new remote player: {pid}\")\n                self.remote_players[pid] = RemotePlayer(pid, remote_players_data[pid])\n\n        # Remove players no longer present in server state\n        for pid in current_remote_ids - server_remote_ids:\n            print(f\" Removing stale remote player: {pid}\")\n            del self.remote_players[pid]\n\n\n        # Update generic sprites\n        sprites_data = state.get(\"sprites\", {})\n        current_sprite_ids = set(self.sprites.keys())\n        server_sprite_ids = set(sprites_data.keys())\n\n        for sid in server_sprite_ids:\n             if sid in self.sprites:\n                 self.sprites[sid].update_from_server(sprites_data[sid])\n             else:\n                  print(f\" Adding new sprite: {sid}\")\n                  self.sprites[sid] = Sprite(sid, sprites_data[sid])\n        for sid in current_sprite_ids - server_sprite_ids:\n             print(f\" Removing stale sprite: {sid}\")\n             del self.sprites[sid]\n\n\n        # Update entities\n        entities_data = state.get(\"entities\", {})\n        current_entity_ids = set(self.entities.keys())\n        server_entity_ids = set(entities_data.keys())\n\n        for eid in server_entity_ids:\n             if eid in self.entities:\n                 self.entities[eid].update_from_server(entities_data[eid])\n             else:\n                  print(f\" Adding new entity: {eid}\")\n                  self.entities[eid] = Entity(eid, entities_data[eid])\n        for eid in current_entity_ids - server_entity_ids:\n             print(f\" Removing stale entity: {eid}\")\n             del self.entities[eid]\n\n        # Ensure playing state if we received a full update\n        if self.game_state != config.STATE_GAME_OVER: # Don't override game over\n             self.game_state = config.STATE_PLAYING\n\n\n    def update_incremental_game_state(self, update_data: dict[str, any]):\n        \"\"\"Applies partial updates to the game state.\"\"\"\n        # Update specific players\n        player_updates = update_data.get(\"players\", {})\n        for pid, pdata in player_updates.items():\n            if pid == self.client_id:\n                self.player.apply_server_update(pdata)\n                if self.player.is_dead and self.game_state != config.STATE_GAME_OVER:\n                     print(\"Player died (incremental update).\")\n                     self.game_state = config.STATE_GAME_OVER\n            elif pid in self.remote_players:\n                self.remote_players[pid].update_from_server(pdata)\n            else: # New player joined mid-game\n                 print(f\" New player joined (incremental): {pid}\")\n                 self.remote_players[pid] = RemotePlayer(pid, pdata)\n\n        # Update specific sprites\n        sprite_updates = update_data.get(\"sprites\", {})\n        for sid, sdata in sprite_updates.items():\n             if sid in self.sprites:\n                 self.sprites[sid].update_from_server(sdata)\n             else:\n                  print(f\" New sprite added (incremental): {sid}\")\n                  self.sprites[sid] = Sprite(sid, sdata)\n\n        # Update specific entities\n        entity_updates = update_data.get(\"entities\", {})\n        for eid, edata in entity_updates.items():\n             if eid in self.entities:\n                 self.entities[eid].update_from_server(edata)\n             else:\n                  print(f\" New entity added (incremental): {eid}\")\n                  self.entities[eid] = Entity(eid, edata)\n\n        # Handle removals (server might send a specific removal message or just stop sending updates for that ID)\n        # Handling removals via dedicated messages (like 'player_disconnect') is more robust.\n\n    def reset_game(self):\n        \"\"\"Resets the game state (e.g., after death).\"\"\"\n        print(\"Resetting game...\")\n        self.player = Player(config.PLAYER_START_X, config.PLAYER_START_Y, config.PLAYER_START_ANGLE)\n        # Clear dynamic objects (server should resend them)\n        self.remote_players.clear()\n        self.sprites.clear()\n        self.entities.clear()\n        # Re-request state from server or wait for it? Best practice: server sends state on respawn command.\n        # For now, just go back to playing/connecting state\n        self.game_state = config.STATE_CONNECTING # Or STATE_PLAYING if server auto-sends state\n\n    def shutdown(self):\n        \"\"\"Cleans up resources before exiting.\"\"\"\n        print(\"Shutting down...\")\n        self.unload_content()\n        if self.network_client.connected:\n            self.network_client.disconnect()\n        pr.close_window()\n        print(\"Shutdown complete.\")\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    try:\n        game.run()\n    except Exception as e:\n        print(f\"\\n--- FATAL ERROR ---\")\n        import traceback\n        traceback.print_exc()\n        print(f\"-------------------\\n\")\n    finally:\n        # Ensure cleanup happens even if error occurs in run loop\n        if 'game' in locals() and pr.is_window_ready():\n             game.shutdown()"
    },
    {
      "filename": "map.py",
      "metadata": {
        "lines": 42,
        "modified": "2025-04-29T20:26:38.693156"
      },
      "content": "# map.py\nfrom typing import List, Tuple\n\nclass GameMap:\n    def __init__(self):\n        # Example map - 0 = empty space, >0 = wall texture ID\n        self.grid: List[List[int]] = [\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 2, 0, 0, 0, 0, 1],\n            [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],\n            [1, 0, 2, 0, 0, 0, 3, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 3, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\n            [1, 0, 2, 0, 0, 0, 2, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        ]\n        self.width = len(self.grid[0]) if self.grid else 0\n        self.height = len(self.grid) if self.grid else 0\n\n    def get_tile(self, x: int, y: int) -> int:\n        \"\"\"Gets the tile ID at integer map coordinates.\"\"\"\n        if 0 <= x < self.width and 0 <= y < self.height:\n            return self.grid[y][x]\n        return -1 # Return -1 for out of bounds\n\n    def is_wall(self, x: float, y: float) -> bool:\n        \"\"\"Checks if the given world coordinates are inside a wall.\"\"\"\n        map_x = int(x)\n        map_y = int(y)\n        tile = self.get_tile(map_x, map_y)\n        return tile > 0 # Any tile ID > 0 is considered a wall\n\n    def update_map(self, new_grid: List[List[int]]):\n        \"\"\"Updates the map grid (e.g., received from server).\"\"\"\n        self.grid = new_grid\n        self.width = len(self.grid[0]) if self.grid else 0\n        self.height = len(self.grid) if self.grid else 0\n        print(\"Map updated.\")\n\n    # TODO: Add method to load map from file or server data"
    },
    {
      "filename": "network.py",
      "metadata": {
        "lines": 120,
        "modified": "2025-04-29T20:27:55.188684"
      },
      "content": "# network.py\nimport socket\nimport json\nimport time\nimport config\nfrom typing import Optional, Dict, Any, List\n\nclass NetworkClient:\n    def __init__(self):\n        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_ip = config.SERVER_IP\n        self.server_port = config.SERVER_PORT\n        self.connected = False\n        self.buffer = \"\" # Buffer for receiving partial messages\n\n    def connect(self) -> bool:\n        \"\"\"Attempts to connect to the server.\"\"\"\n        try:\n            print(f\"Attempting to connect to {self.server_ip}:{self.server_port}...\")\n            self.client.settimeout(2.0) # Timeout for connection attempt\n            self.client.connect((self.server_ip, self.server_port))\n            self.client.settimeout(config.SOCKET_TIMEOUT) # Set to non-blocking/short timeout for recv\n            # Optional: Send an initial handshake message\n            # self.send_data({\"type\": \"connect\", \"player_name\": \"Player\"})\n            self.connected = True\n            print(\"Connection successful.\")\n            return True\n        except socket.timeout:\n             print(\"Connection attempt timed out.\")\n             self.connected = False\n             return False\n        except socket.error as e:\n            print(f\"Connection failed: {e}\")\n            self.connected = False\n            return False\n\n    def send_data(self, data: Dict[str, Any]):\n        \"\"\"Sends Python dictionary data to the server as JSON.\"\"\"\n        if not self.connected:\n            print(\"Error: Not connected to server.\")\n            return\n\n        try:\n            message = json.dumps(data) + '\\n' # Add newline as delimiter\n            self.client.sendall(message.encode('utf-8'))\n            # print(f\"Sent: {message.strip()}\") # Debug\n        except socket.error as e:\n            print(f\"Network send error: {e}\")\n            self.connected = False # Assume disconnect on send error\n        except Exception as e:\n            print(f\"Error encoding or sending data: {e}\")\n\n\n    def receive_data(self) -> List[Dict[str, Any]]:\n        \"\"\"Receives data from the server, handling non-blocking and message framing.\"\"\"\n        if not self.connected:\n            return []\n\n        messages = []\n        try:\n            # Keep receiving small chunks until a socket timeout (no more data currently)\n            while True:\n                 chunk = self.client.recv(4096).decode('utf-8')\n                 if not chunk:\n                      # Empty chunk usually means server disconnected gracefully\n                      print(\"Server disconnected.\")\n                      self.connected = False\n                      return [] # Return empty list, signal disconnection upstream\n\n                 self.buffer += chunk\n                 # Process complete messages (delimited by newline)\n                 while '\\n' in self.buffer:\n                    message_str, self.buffer = self.buffer.split('\\n', 1)\n                    if message_str:\n                        try:\n                            message_dict = json.loads(message_str)\n                            messages.append(message_dict)\n                            # print(f\"Recv: {message_dict}\") # Debug\n                        except json.JSONDecodeError:\n                             print(f\"Warning: Received invalid JSON: {message_str}\")\n        except socket.timeout:\n            # This is expected in non-blocking mode when no data is available\n            pass\n        except socket.error as e:\n            # Handle other socket errors (e.g., connection reset)\n             if e.errno == 104: # Connection reset by peer\n                 print(\"Server connection lost (reset by peer).\")\n             elif e.errno == 11: # Resource temporarily unavailable (EAGAIN/EWOULDBLOCK)\n                 # This can happen instead of timeout sometimes\n                  pass # Ignore, just means no data right now\n             else:\n                 print(f\"Network receive error: {e}\")\n             self.connected = False # Assume disconnect on error\n        except Exception as e:\n            print(f\"Error decoding received data: {e}\")\n            # Potentially corrupt data, maybe clear buffer?\n            # self.buffer = \"\"\n\n        return messages\n\n\n    def disconnect(self):\n        \"\"\"Closes the connection to the server.\"\"\"\n        if self.connected:\n            print(\"Disconnecting from server...\")\n            try:\n                 # Optional: Send a disconnect message\n                 self.send_data({\"type\": \"disconnect\"})\n                 # Wait briefly to allow message to send? Not strictly needed with TCP.\n                 # time.sleep(0.1)\n                 self.client.shutdown(socket.SHUT_RDWR) # Graceful shutdown\n            except socket.error as e:\n                 print(f\"Error during shutdown: {e}\")\n            finally:\n                self.client.close()\n                self.connected = False\n                print(\"Disconnected.\")\n        # Recreate socket for potential reconnection\n        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.buffer = \"\""
    },
    {
      "filename": "player.py",
      "metadata": {
        "lines": 146,
        "modified": "2025-04-29T21:23:22.236907"
      },
      "content": "# player.py\nimport pyray as pr\nimport math\nimport config\nfrom map import GameMap # Import GameMap for collision detection\nfrom typing import Tuple\n\nclass Player:\n    def __init__(self, x: float, y: float, angle: float):\n        self.x = x\n        self.y = y\n        self.angle = angle # Radians\n        self.health = config.PLAYER_HEALTH_START\n        self.is_shooting = False\n        self.is_dead = False\n        self.is_running = False\n        self.delta_time = 0.0 # Will be updated each frame\n\n    def handle_input(self, game_map: GameMap):\n        \"\"\"Processes player input for movement and actions.\"\"\"\n        if self.is_dead:\n            return\n\n        move_speed = config.PLAYER_MOVE_SPEED\n        rot_speed = config.PLAYER_ROTATION_SPEED * self.delta_time\n\n        # Rotation\n        if pr.is_key_down(pr.KeyboardKey.KEY_LEFT) or pr.is_key_down(pr.KeyboardKey.KEY_A):\n            self.angle -= rot_speed\n        if pr.is_key_down(pr.KeyboardKey.KEY_RIGHT) or pr.is_key_down(pr.KeyboardKey.KEY_D):\n            self.angle += rot_speed\n\n        # Ensure angle stays within 0 to 2*PI\n        self.angle = self.angle % (2 * math.pi)\n        if self.angle < 0:\n            self.angle += (2 * math.pi)\n\n        # Movement Speed (Running)\n        self.is_running = pr.is_key_down(pr.KeyboardKey.KEY_LEFT_SHIFT) or pr.is_key_down(pr.KeyboardKey.KEY_RIGHT_SHIFT)\n        if self.is_running:\n             move_speed *= config.PLAYER_RUN_MULTIPLIER\n\n        move_step = move_speed * self.delta_time\n        move_x = 0.0\n        move_y = 0.0\n\n        # Forward/Backward Movement\n        if pr.is_key_down(pr.KeyboardKey.KEY_UP) or pr.is_key_down(pr.KeyboardKey.KEY_W):\n            move_x += math.cos(self.angle) * move_step\n            move_y += math.sin(self.angle) * move_step\n        if pr.is_key_down(pr.KeyboardKey.KEY_DOWN) or pr.is_key_down(pr.KeyboardKey.KEY_S):\n            move_x -= math.cos(self.angle) * move_step\n            move_y -= math.sin(self.angle) * move_step\n\n        # Strafing (Optional - add if desired)\n        # angle_strafe = self.angle + math.pi / 2.0\n        # if pr.is_key_down(pr.KeyboardKey.KEY_Q): # Strafe Left\n        #     move_x -= math.cos(angle_strafe) * move_step\n        #     move_y -= math.sin(angle_strafe) * move_step\n        # if pr.is_key_down(pr.KeyboardKey.KEY_E): # Strafe Right\n        #     move_x += math.cos(angle_strafe) * move_step\n        #     move_y += math.sin(angle_strafe) * move_step\n\n        # Simple Collision Detection (check target position before moving)\n        target_x = self.x + move_x\n        target_y = self.y + move_y\n\n        # Check collision separately for X and Y for smoother sliding against walls\n        if not game_map.is_wall(target_x, self.y):\n            self.x = target_x\n        if not game_map.is_wall(self.x, target_y):\n            self.y = target_y\n\n        # Shooting (simple toggle for now)\n        if pr.is_mouse_button_pressed(pr.MouseButton.MOUSE_BUTTON_LEFT):\n             self.is_shooting = True # Server should handle cooldown/ammo\n        else:\n             # This might need refinement - maybe only set to false after server ack?\n             # Or based on animation duration? For now, just reset if not pressed.\n             # A better approach is often making is_shooting True for one frame on press.\n             self.is_shooting = False # Reset shooting state\n\n    def update(self, delta_time: float, game_map: GameMap):\n        \"\"\"Updates player state based on input and time.\"\"\"\n        self.delta_time = delta_time\n        # Handle input only if not dead\n        if not self.is_dead:\n            self.handle_input(game_map)\n\n        # Update dead state based on health (server will likely be the authority)\n        if self.health <= 0:\n            self.is_dead = True\n            # Potentially trigger respawn logic here or wait for server command\n\n    def get_state_dict(self) -> dict:\n        \"\"\"Returns player state in a format suitable for sending over network.\"\"\"\n        return {\n            \"x\": round(self.x, 4),\n            \"y\": round(self.y, 4),\n            \"angle\": round(self.angle, 4),\n            \"health\": self.health,\n            \"is_shooting\": self.is_shooting,\n            \"is_dead\": self.is_dead,\n            \"is_running\": self.is_running # Send running state for sprite animation\n            # Add other relevant state like weapon, ammo, etc. later\n        }\n\n    def apply_server_update(self, data: dict):\n        \"\"\"Applies authoritative state updates from the server (e.g., health).\"\"\"\n        # Important: Avoid directly setting position/angle if server doesn't correct it,\n        # unless implementing server reconciliation. Usually, server only sends corrections\n        # or health/death status.\n        self.health = data.get(\"health\", self.health)\n        self.is_dead = data.get(\"is_dead\", self.is_dead)\n        # Potentially server could force position if cheating detected or on spawn:\n        # self.x = data.get(\"x\", self.x)\n        # self.y = data.get(\"y\", self.y)\n        # self.angle = data.get(\"angle\", self.angle)\n\n    def get_pos_tuple(self) -> Tuple[float, float]:\n        return (self.x, self.y)\n\n    def get_dir_vector(self) -> Tuple[float, float]:\n        return (math.cos(self.angle), math.sin(self.angle))\n\n    def get_plane_vector(self) -> Tuple[float, float]:\n        \"\"\"\n        Returns the camera plane vector.\n        This version uses the definition common in many raycasting tutorials\n        (e.g., LodeV), directly relating plane to direction components.\n        The scaling factor (0.66) determines the field of view.\n        \"\"\"\n        dir_x = math.cos(self.angle)\n        dir_y = math.sin(self.angle)\n        # Common FOV scaling factor (approx 90 degrees horizontal)\n        # Adjust this value to change the FOV if needed\n        scale = 0.66\n\n        # Calculate plane vector components based on direction\n        # plane_x = -dir_y * scale\n        # plane_y = dir_x * scale\n        # OR the other perpendicular:\n        plane_x = -dir_y * scale\n        plane_y = dir_x * scale\n\n        return (plane_x, plane_y)"
    },
    {
      "filename": "remote_player.py",
      "metadata": {
        "lines": 117,
        "modified": "2025-04-29T21:07:19.541379"
      },
      "content": "# remote_player.py\nimport math\nfrom typing import Optional\nfrom typing import Tuple\nimport config\n\nclass RemotePlayer:\n    def __init__(self, player_id: str, data: dict):\n        self.id = player_id\n        self.x: float = 0.0\n        self.y: float = 0.0\n        self.angle: float = 0.0\n        self.health: int = 100\n        self.is_shooting: bool = False\n        self.is_dead: bool = False\n        self.is_running: bool = False\n        self.is_walking: bool = False # Determine based on position change\n        self.last_update_time: float = 0.0 # For interpolation or state detection\n        self.last_x: float = 0.0\n        self.last_y: float = 0.0\n        self.sprite_name = \"WinterGuard\" # Could be sent by server if different player types\n\n        self.update_from_server(data) # Initialize with first data packet\n\n    def update_from_server(self, data: dict):\n        \"\"\"Updates the state of this remote player from server data.\"\"\"\n        new_x = data.get(\"x\", self.x)\n        new_y = data.get(\"y\", self.y)\n\n        # Determine if walking/running based on position change and server flag\n        # Threshold check helps ignore minor network jitter if not interpolating\n        pos_changed = abs(new_x - self.x) > 0.01 or abs(new_y - self.y) > 0.01\n\n        self.is_running = data.get(\"is_running\", False) and pos_changed\n        self.is_walking = (not self.is_running) and pos_changed\n\n        self.last_x = self.x\n        self.last_y = self.y\n        self.x = new_x\n        self.y = new_y\n        self.angle = data.get(\"angle\", self.angle) # Angle needed to face sprite correctly\n        self.health = data.get(\"health\", self.health)\n        self.is_shooting = data.get(\"is_shooting\", False) # Might need timing/animation logic\n        self.is_dead = data.get(\"is_dead\", False)\n        # Record update time if needed for interpolation (requires pr.get_time())\n        # self.last_update_time = pr.get_time()\n\n    def get_texture_index(self, player_angle_rad: float) -> int:\n        \"\"\"Determines the correct sprite index based on state and viewing angle.\"\"\"\n        if self.is_dead:\n            # TODO: Add dead sprite index? For now, maybe just idle front.\n             return config.SPRITE_WINTERGUARD_IDLE_START -1 # Use 0-based index\n\n        # Calculate relative angle between observer and sprite's facing direction\n        # For simplicity now, we'll base direction on the *observer's* view angle to the sprite\n        # A better way is using the sprite's *own* angle from server data.\n\n        # Angle from player (observer) to this remote player\n        dx = self.x - player_pos[0]\n        dy = self.y - player_pos[1]\n        angle_to_sprite = math.atan2(dy, dx)\n\n        # Angle difference between player's view and the vector to the sprite\n        delta_angle = player_angle_rad - angle_to_sprite\n\n        # Normalize angle difference to be between -pi and +pi\n        while delta_angle <= -math.pi: delta_angle += 2 * math.pi\n        while delta_angle > math.pi: delta_angle -= 2 * math.pi\n\n        # Determine direction index (0-7) based on relative angle\n        # 0: back, 2: right, 4: front, 6: left (approx)\n        # We need to map our 1-8 texture scheme to this.\n        # Texture 1 = front (facing camera). Let's map delta_angle around 0 to index 0 (for texture 1)\n        # Texture 5 = back (facing away). Map delta_angle around +/- pi to index 4 (for texture 5)\n        direction_index = int( (delta_angle + math.pi) / (2 * math.pi) * config.SPRITE_DIRECTIONS + 0.5 + config.SPRITE_DIRECTIONS // 2) % config.SPRITE_DIRECTIONS\n        # This maps: 0 rad -> dir 4 (front), pi/-pi -> dir 0 (back), pi/2 -> dir 2 (left), -pi/2 -> dir 6 (right)\n        # Let's remap to match WinterGuard_01 (front) = 0, clockwise\n        # WinterGuard_01 = Front = dir 4 -> final index 0\n        # WinterGuard_02 = Front-Right = dir 5 -> final index 1\n        # WinterGuard_03 = Right = dir 6 -> final index 2\n        # WinterGuard_04 = Back-Right = dir 7 -> final index 3\n        # WinterGuard_05 = Back = dir 0 -> final index 4\n        # WinterGuard_06 = Back-Left = dir 1 -> final index 5\n        # WinterGuard_07 = Left = dir 2 -> final index 6\n        # WinterGuard_08 = Front-Left = dir 3 -> final index 7\n        remap = {4: 0, 5: 1, 6: 2, 7: 3, 0: 4, 1: 5, 2: 6, 3: 7}\n        final_direction_index = remap.get(direction_index, 0) # Default to front\n\n        # Determine state base index\n        if self.is_running:\n             base_index = config.SPRITE_WINTERGUARD_RUN_START\n        elif self.is_walking:\n            base_index = config.SPRITE_WINTERGUARD_WALK_START\n        # elif self.is_shooting: # Add shooting state later if needed\n        #     base_index = SHOOTING_START_INDEX\n        else: # Idle\n             base_index = config.SPRITE_WINTERGUARD_IDLE_START\n\n        # Calculate final texture index (using 1-based indexing from files)\n        # Texture index is 1-based, add direction offset\n        texture_file_index = base_index + final_direction_index\n\n        # Return 0-based index for list access in AssetsManager\n        print(\"Calculated texture file index: \", texture_file_index)\n        return texture_file_index - 1\n\n\n# Global variable to hold player position and angle for texture calculation\n# This is a simplification; passing player state explicitly is better practice\nplayer_pos: Tuple = (0.0, 0.0)\nplayer_angle_rad: float = 0.0\n\ndef set_observer_state(pos: Tuple, angle: float):\n    \"\"\"Updates the global observer state needed for sprite direction calculation.\"\"\"\n    global player_pos, player_angle_rad\n    player_pos = pos\n    player_angle_rad = angle"
    },
    {
      "filename": "renderer.py",
      "metadata": {
        "lines": 362,
        "modified": "2025-04-30T02:16:56.683559"
      },
      "content": "# renderer.py\nimport pyray as pr\nimport math # <-- Added import\nimport config\nfrom typing import List, Dict, Tuple, Optional\n\n# Import game objects\nfrom player import Player\nfrom remote_player import RemotePlayer, set_observer_state # Import the function too\nfrom sprite import Sprite\nfrom entity import Entity\nfrom map import GameMap\nfrom assets_manager import AssetsManager\n\n# Structure to hold ray hit information\nclass RayHit:\n    def __init__(self, dist: float, wall_id: int, hit_x: float, hit_y: float, side: int, ray_angle: float):\n        self.dist = dist          # Distance to wall hit\n        self.wall_id = wall_id    # Texture ID of the wall hit\n        self.hit_x = hit_x        # Exact world X coordinate of the hit\n        self.hit_y = hit_y        # Exact world Y coordinate of the hit\n        self.side = side          # 0 for Y-side hit, 1 for X-side hit (for shading/texture coord)\n        self.ray_angle = ray_angle # Angle of the ray that caused the hit\n\nclass Renderer:\n    def __init__(self, assets_manager: AssetsManager):\n        self.assets_manager = assets_manager\n        self.z_buffer: List[float] = [config.MAX_RENDER_DEPTH] * config.SCREEN_WIDTH # For sprite occlusion\n\n    def _cast_single_ray(self, player: Player, game_map: GameMap, ray_angle: float) -> Optional[RayHit]:\n        \"\"\"Casts a single ray and returns hit information or None.\"\"\"\n        # Normalize angle\n        ray_angle %= (2 * math.pi)\n        if ray_angle < 0: ray_angle += 2 * math.pi\n\n        map_x = int(player.x)\n        map_y = int(player.y)\n\n        # Distances to next X and Y grid lines\n        # Avoid division by zero for horizontal/vertical rays\n        cos_ray_angle = math.cos(ray_angle)\n        sin_ray_angle = math.sin(ray_angle)\n        delta_dist_x = abs(1 / cos_ray_angle) if cos_ray_angle != 0 else float('inf')\n        delta_dist_y = abs(1 / sin_ray_angle) if sin_ray_angle != 0 else float('inf')\n\n\n        # Length of ray from current position to next x or y-side\n        side_dist_x: float\n        side_dist_y: float\n\n        # Step direction (1 or -1)\n        step_x: int\n        step_y: int\n\n        if cos_ray_angle < 0:\n            step_x = -1\n            side_dist_x = (player.x - map_x) * delta_dist_x\n        else:\n            step_x = 1\n            side_dist_x = (map_x + 1.0 - player.x) * delta_dist_x\n\n        if sin_ray_angle < 0:\n            step_y = -1\n            side_dist_y = (player.y - map_y) * delta_dist_y\n        else:\n            step_y = 1\n            side_dist_y = (map_y + 1.0 - player.y) * delta_dist_y\n\n        hit = 0\n        side = 0 # 0 for Y-side hit, 1 for X-side hit\n        # Use a large number for initial distance comparison, not actual distance yet\n        current_dist_x = side_dist_x\n        current_dist_y = side_dist_y\n        steps = 0\n        max_steps = int(config.MAX_RENDER_DEPTH * 2) # Limit steps to prevent infinite loops\n\n        while hit == 0 and steps < max_steps:\n            steps += 1\n            # Jump to next map square, OR in x-direction, OR in y-direction\n            if current_dist_x < current_dist_y:\n                # Use current_dist_x for distance calculation before incrementing\n                # perp_wall_dist calculation needs the map coords *before* the step that hits\n                map_x += step_x\n                dist = current_dist_x # Approximate distance travelled\n                current_dist_x += delta_dist_x\n                side = 1 # Hit an X-side (vertical line)\n            else:\n                map_y += step_y\n                dist = current_dist_y # Approximate distance travelled\n                current_dist_y += delta_dist_y\n                side = 0 # Hit a Y-side (horizontal line)\n\n            # Check if ray has hit a wall\n            if 0 <= map_x < game_map.width and 0 <= map_y < game_map.height:\n                 wall_id = game_map.grid[map_y][map_x]\n                 if wall_id > 0:\n                    hit = wall_id\n            else:\n                 # Hit edge of map boundaries - treat as a distant wall or stop ray\n                 hit = -1 # Special value indicating out of bounds\n                 break # Stop casting\n\n            # Check distance limit based on approximate distance travelled\n            if dist > config.MAX_RENDER_DEPTH:\n                hit = -2 # Indicate hit max distance\n                break\n\n\n        if hit > 0:\n             # Calculate perpendicular distance to avoid fisheye effect\n             # Use map coordinates of the *wall hit*\n             if side == 1: # Hit X-side\n                 # (map_x - player.x + (1 - step_x) / 2) is distance along X axis from player to wall center\n                 perp_wall_dist = (map_x - player.x + (1 - step_x) / 2) / cos_ray_angle if cos_ray_angle != 0 else float('inf')\n             else: # Hit Y-side\n                 # (map_y - player.y + (1 - step_y) / 2) is distance along Y axis from player to wall center\n                 perp_wall_dist = (map_y - player.y + (1 - step_y) / 2) / sin_ray_angle if sin_ray_angle != 0 else float('inf')\n\n             # Clamp distance if it went slightly beyond due to calculation method\n             perp_wall_dist = max(0.01, perp_wall_dist) # Avoid zero distance\n\n             # Calculate exact hit coordinates (needed for texture mapping)\n             hit_x = player.x + perp_wall_dist * cos_ray_angle\n             hit_y = player.y + perp_wall_dist * sin_ray_angle\n\n             return RayHit(perp_wall_dist, hit, hit_x, hit_y, side, ray_angle)\n\n        return None # No hit within max distance or map bounds\n\n\n    def _calculate_texture_x(self, hit: RayHit, player: Player) -> float:\n         \"\"\"Calculates the X coordinate on the texture for a wall slice.\"\"\"\n         # Use exact hit coordinates for texture calculation\n         wall_x: float # Where exactly the wall was hit (0.0 to 1.0 on the side)\n         if hit.side == 1: # Hit an X-side (vertical wall line)\n             # Use the Y coordinate of the hit point relative to the map tile floor\n             wall_x = hit.hit_y - math.floor(hit.hit_y)\n             # Flip texture coordinate if ray is moving left (hitting east face from west)\n             if math.cos(hit.ray_angle) < 0:\n                 wall_x = 1.0 - wall_x\n         else: # Hit a Y-side (horizontal wall line)\n             # Use the X coordinate of the hit point relative to the map tile floor\n             wall_x = hit.hit_x - math.floor(hit.hit_x)\n             # Flip texture coordinate if ray is moving up (hitting south face from north)\n             # Screen Y is down. If sin(angle) > 0, ray moves \"down\" on screen (positive Y in world?)\n             # Let's assume world Y increases upwards. sin(angle) > 0 means moving up.\n             if math.sin(hit.ray_angle) > 0:\n                 wall_x = 1.0 - wall_x\n\n         tex_x = int(wall_x * config.TEXTURE_SIZE)\n         # Clamp to texture bounds just in case\n         tex_x = max(0, min(tex_x, config.TEXTURE_SIZE - 1))\n         return tex_x\n\n\n    def draw_frame(self,\n                   player: Player,\n                   game_map: GameMap,\n                   remote_players: Dict[str, RemotePlayer],\n                   sprites: Dict[str, Sprite],\n                   entities: Dict[str, Entity]):\n        \"\"\"Draws the entire game scene for one frame.\"\"\"\n        pr.begin_drawing()\n        pr.clear_background(pr.BLACK) # Clear entire screen\n\n        self.draw_floor_ceiling()\n        self.draw_walls(player, game_map)\n        self.draw_objects(player, remote_players, sprites, entities)\n        self.draw_ui(player) # Draw UI on top\n\n        # Draw FPS\n        pr.draw_fps(10, 10)\n\n        pr.end_drawing()\n\n    def draw_floor_ceiling(self):\n        \"\"\"Draws the floor and ceiling.\"\"\"\n        # Ceiling\n        pr.draw_rectangle(0, 0, config.SCREEN_WIDTH, config.SCREEN_HEIGHT // 2, config.COLOR_CEILING)\n        # Floor\n        pr.draw_rectangle(0, config.SCREEN_HEIGHT // 2, config.SCREEN_WIDTH, config.SCREEN_HEIGHT // 2, config.COLOR_FLOOR)\n\n\n    def draw_walls(self, player: Player, game_map: GameMap):\n        \"\"\"Casts rays and draws wall slices.\"\"\"\n        start_angle = player.angle - config.PLAYER_FOV / 2.0\n        angle_step = config.PLAYER_FOV / config.NUM_RAYS\n\n        # Reset Z-Buffer for this frame\n        self.z_buffer = [config.MAX_RENDER_DEPTH] * config.SCREEN_WIDTH\n\n        for i in range(config.NUM_RAYS):\n            ray_angle = start_angle + i * angle_step\n            hit = self._cast_single_ray(player, game_map, ray_angle)\n\n            screen_x = i * config.RENDER_SCALE_FACTOR # Scale wall slice width\n\n            if hit:\n                # Store distance in Z-buffer for sprite occlusion\n                # Clamp distance to prevent issues\n                z_dist = max(0.01, hit.dist)\n                for k in range(config.RENDER_SCALE_FACTOR):\n                    buffer_idx = screen_x + k\n                    if 0 <= buffer_idx < config.SCREEN_WIDTH:\n                        self.z_buffer[buffer_idx] = z_dist\n\n                # Calculate wall slice height - avoid division by zero\n                line_height = int(config.SCREEN_HEIGHT / z_dist) if z_dist > 0.01 else config.SCREEN_HEIGHT * 100\n\n                # Calculate drawing start and end points on screen\n                draw_start = -line_height // 2 + config.SCREEN_HEIGHT // 2\n                draw_end = line_height // 2 + config.SCREEN_HEIGHT // 2\n\n                # Get texture\n                wall_texture = self.assets_manager.get_wall_texture(hit.wall_id)\n\n                # Calculate texture X coordinate\n                tex_x = self._calculate_texture_x(hit, player)\n\n                # Define source rectangle on the texture\n                tex_rect_src = pr.Rectangle(tex_x, 0, 1, float(wall_texture.height)) # Use texture height\n\n                # Define destination rectangle on the screen\n                tex_rect_dest = pr.Rectangle(float(screen_x), float(draw_start), float(config.RENDER_SCALE_FACTOR), float(line_height))\n\n                # Apply simple shading based on wall side\n                tint = pr.WHITE\n                if hit.side == 1: # X-side hit, make slightly darker\n                     tint = pr.Color(200, 200, 200, 255)\n\n                # Draw the texture slice\n                pr.draw_texture_pro(wall_texture, tex_rect_src, tex_rect_dest, pr.Vector2(0, 0), 0.0, tint)\n\n            # else: # No need to explicitly clear z_buffer if initialized each frame\n            #      pass\n\n\n    def draw_objects(self,\n                      player: Player,\n                      remote_players: Dict[str, RemotePlayer],\n                      sprites: Dict[str, Sprite],\n                      entities: Dict[str, Entity]):\n        \"\"\"Draws all sprites and entities, sorted by distance.\"\"\"\n\n        set_observer_state(player.get_pos_tuple(), player.angle)\n\n        # --- Combine objects ---\n        all_objects = []\n        for rp in remote_players.values():\n            if not rp.is_dead:\n                tex_index = rp.get_texture_index(player.angle)\n                texture = self.assets_manager.get_sprite_texture(rp.sprite_name, tex_index)\n                all_objects.append({\"x\": rp.x, \"y\": rp.y, \"texture\": texture, \"scale\": config.SPRITE_SCALE, \"obj_ref\": rp })\n        for sp in sprites.values():\n             if sp.should_draw():\n                texture = self.assets_manager.get_sprite_texture(sp.texture_name, sp.texture_index)\n                all_objects.append({\"x\": sp.x, \"y\": sp.y, \"texture\": texture, \"scale\": sp.scale, \"obj_ref\": sp })\n        for ent in entities.values():\n            if ent.should_draw():\n                texture = self.assets_manager.get_sprite_texture(ent.texture_name, ent.texture_index)\n                all_objects.append({\"x\": ent.x, \"y\": ent.y, \"texture\": texture, \"scale\": ent.scale, \"obj_ref\": ent })\n\n        # --- Sort by distance ---\n        for obj in all_objects:\n            dx = obj[\"x\"] - player.x\n            dy = obj[\"y\"] - player.y\n            obj[\"dist_sq\"] = dx*dx + dy*dy\n        all_objects.sort(key=lambda s: s[\"dist_sq\"], reverse=True)\n\n        # --- Get Player Vectors ---\n        player_dir_x, player_dir_y = player.get_dir_vector()\n        player_plane_x, player_plane_y = player.get_plane_vector()\n\n        # --- Draw sorted objects ---\n        for obj in all_objects:\n            # --- Step 1: Translate ---\n            sprite_x = obj[\"x\"] - player.x\n            sprite_y = obj[\"y\"] - player.y\n\n            # --- Step 2: Transform ---\n            det = (player_plane_x * player_dir_y - player_dir_x * player_plane_y)\n            if abs(det) < 1e-9: continue\n            inv_det = 1.0 / det\n            transform_x = inv_det * (player_dir_y * sprite_x - player_dir_x * sprite_y)\n            transform_y = inv_det * (-player_plane_y * sprite_x + player_plane_x * sprite_y)\n\n            # --- Step 3: Check Depth ---\n            if transform_y <= 0.1: continue\n\n            # --- Step 4: Calculate Screen Coords & Dimensions ---\n            sprite_screen_x = int((config.SCREEN_WIDTH / 2) * (1 + transform_x / transform_y))\n            sprite_height = abs(int(config.SCREEN_HEIGHT / transform_y * obj[\"scale\"]))\n            current_texture = obj.get(\"texture\")\n            aspect_ratio = 1.0\n            if current_texture and current_texture.height != 0:\n                 aspect_ratio = float(current_texture.width) / float(current_texture.height)\n            sprite_width = abs(int(sprite_height * aspect_ratio))\n\n            # --- Step 5: Calculate Drawing Bounds (Clamped) ---\n            vertical_offset = sprite_height // 2 # Offset to place base near horizon\n            draw_start_y = -sprite_height // 2 + config.SCREEN_HEIGHT // 2 + vertical_offset\n            draw_end_y = sprite_height // 2 + config.SCREEN_HEIGHT // 2 + vertical_offset\n            draw_start_y_clamped = max(0, draw_start_y)\n            draw_end_y_clamped = min(config.SCREEN_HEIGHT, draw_end_y)\n\n            draw_start_x = -sprite_width // 2 + sprite_screen_x\n            draw_end_x = sprite_width // 2 + sprite_screen_x\n            draw_start_x_clamped = max(0, draw_start_x)\n            draw_end_x_clamped = min(config.SCREEN_WIDTH, draw_end_x)\n\n            # --- Step 6: Draw Stripes ---\n            tex_rect_src_h = float(current_texture.height) if current_texture else 0.0\n            tex_rect_src_w = float(current_texture.width) if current_texture else 0.0\n\n            if tex_rect_src_h <= 0 or tex_rect_src_w <= 0 or sprite_width <= 0: continue\n\n            clamped_dest_height = float(draw_end_y_clamped - draw_start_y_clamped)\n\n            if clamped_dest_height > 0 and sprite_height > 0:\n                visible_screen_width = float(draw_end_x_clamped - draw_start_x_clamped)\n\n                if visible_screen_width > 0:\n                    for stripe in range(draw_start_x_clamped, draw_end_x_clamped):\n                        if 0 <= stripe < config.SCREEN_WIDTH and transform_y < self.z_buffer[stripe]:\n\n                            # Calculate Texture X (mapping visible screen part to texture)\n                            visible_el_x = stripe - draw_start_x_clamped\n                            tex_x = int(visible_el_x * tex_rect_src_w / visible_screen_width)\n\n                            if 0 <= tex_x < tex_rect_src_w:\n                                # Calculate Texture Y/Height based on vertical clamping\n                                clip_top_pixels_screen = draw_start_y_clamped - draw_start_y\n                                src_y_offset = (clip_top_pixels_screen / float(sprite_height)) * tex_rect_src_h\n                                visible_height_ratio = clamped_dest_height / float(sprite_height)\n                                src_h = visible_height_ratio * tex_rect_src_h\n                                src_y = max(0.0, min(src_y_offset, tex_rect_src_h))\n                                src_h = max(0.0, min(src_h, tex_rect_src_h - src_y))\n\n                                if src_h > 0:\n                                    # Define Source and Destination Rects for this stripe\n                                    stripe_src_rect = pr.Rectangle(float(tex_x), src_y, 1.0, src_h)\n                                    stripe_dest_rect = pr.Rectangle(float(stripe), float(draw_start_y_clamped), 1.0, clamped_dest_height)\n                                    # Draw\n                                    pr.draw_texture_pro(current_texture, stripe_src_rect, stripe_dest_rect, pr.Vector2(0,0), 0.0, pr.WHITE)\n\n    def draw_ui(self, player: Player):\n         \"\"\"Draws User Interface elements like health, ammo, etc.\"\"\"\n         # Simple health bar example\n         health_percentage = max(0.0, player.health / config.PLAYER_HEALTH_START) # Ensure >= 0\n         health_bar_width = 200\n         health_bar_height = 20\n         health_current_width = int(health_bar_width * health_percentage)\n\n         pr.draw_rectangle(10, config.SCREEN_HEIGHT - 30, health_bar_width, health_bar_height, pr.GRAY)\n         pr.draw_rectangle(10, config.SCREEN_HEIGHT - 30, health_current_width, health_bar_height, pr.RED)\n         pr.draw_text(f\"HP: {player.health}\", 15, config.SCREEN_HEIGHT - 28, 18, pr.WHITE)\n\n         # Draw \"DEAD\" message if applicable\n         if player.is_dead:\n             msg = \"YOU ARE DEAD\"\n             text_width = pr.measure_text(msg, 60)\n             pr.draw_text(msg, (config.SCREEN_WIDTH - text_width)//2, config.SCREEN_HEIGHT//2 - 30, 60, pr.RED)"
    },
    {
      "filename": "server.py",
      "metadata": {
        "lines": 280,
        "modified": "2025-04-29T21:41:49.790065"
      },
      "content": "# server.py\nimport socketserver\nimport threading\nimport json\nimport time\nimport uuid # To generate unique IDs (alternative to ip:port)\nimport math # <-- Added import\nfrom typing import Dict, Any, Optional\n\ntry:\n    from map import GameMap\nexcept ImportError:\n    print(\"Warning: map.py not found. Cannot load map data.\")\n    GameMap = None # Define as None if import fails\n\n# Reuse configuration from the client side for host/port\ntry:\n    import config\n    SERVER_HOST = config.SERVER_IP # Use the IP specified in config\n    SERVER_PORT = config.SERVER_PORT\n    print(f\"Server Configuration: Host={SERVER_HOST}, Port={SERVER_PORT}\")\nexcept ImportError:\n    print(\"Warning: config.py not found. Using default server settings.\")\n    SERVER_HOST = \"127.0.0.1\"\n    SERVER_PORT = 5555\n    # Define a minimal map if config isn't available\n    DEFAULT_MAP_GRID = [\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 2, 0, 0, 0, 0, 1],\n        [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],\n        [1, 0, 2, 0, 0, 0, 3, 0, 0, 1],\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 3, 0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\n        [1, 0, 2, 0, 0, 0, 2, 0, 0, 1],\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ]\n\n\n# --- Global Server State ---\n# Thread-safe access needed if modifying complex structures concurrently.\n# For simple dict updates on player states, Python's GIL provides some safety,\n# but a lock is better practice for adding/removing clients.\nserver_state_lock = threading.Lock()\n# Maps client_id to its handler instance (for sending data)\nconnected_clients: Dict[str, 'ClientHandler'] = {}\n# Maps client_id to the latest player state dictionary received\nplayer_states: Dict[str, Dict[str, Any]] = {}\n# Static map data (load from config or file ideally)\ngame_map_data = {\"grid\": []} # Default empty map\nif GameMap: # Check if import succeeded\n    try:\n        # Use the imported GameMap class correctly\n        game_map_data = {\"grid\": GameMap().grid}\n        print(\"Loaded map data from map.GameMap\")\n    except Exception as e:\n        print(f\"Error loading map data from GameMap: {e}\")\nelif 'DEFAULT_MAP_GRID' in locals(): # Fallback if GameMap failed but config fallback worked\n     game_map_data = {\"grid\": DEFAULT_MAP_GRID}\n     print(\"Using default map grid due to import/config issues.\")\nelse:\n     print(\"Warning: Could not load map data.\")\n\n# Get player start position from config if possible, otherwise use defaults\ntry:\n    player_start_x = config.PLAYER_START_X\n    player_start_y = config.PLAYER_START_Y\n    player_start_angle = config.PLAYER_START_ANGLE # Might be useful\nexcept (NameError, AttributeError):\n    player_start_x = 3.5\n    player_start_y = 3.5\n    player_start_angle = 0.0\n\n# DEBUG: Place sprite 2 units in front of player start\ndebug_sprite_x = player_start_x + 2.0 * math.cos(player_start_angle)\ndebug_sprite_y = player_start_y + 2.0 * math.sin(player_start_angle)\nprint(f\"Debug sprite ('sprite_guard_npc') placed at: ({debug_sprite_x:.2f}, {debug_sprite_y:.2f})\")\n\n# Basic example sprites/entities (server dictates these)\nsprite_states: Dict[str, Dict[str, Any]] = {\n    # \"sprite_barrel_1\": {\"id\": \"sprite_barrel_1\", \"x\": 5.5, \"y\": 2.5, \"texture_name\": \"Barrel\", \"texture_index\": 0, \"scale\": 0.6},\n    # --- MODIFIED POSITION ---\n    \"sprite_guard_npc\": {\n        \"id\": \"sprite_guard_npc\",\n        \"x\": debug_sprite_x, # Set X for debugging\n        \"y\": debug_sprite_y, # Set Y for debugging\n        \"texture_name\": \"WinterGuard\",\n        \"texture_index\": 1,\n        \"scale\": .95,\n        \"health\": 50\n        }\n}\nentity_states: Dict[str, Dict[str, Any]] = {\n     # \"entity_key_1\": {\"id\": \"entity_key_1\", \"x\": 2.5, \"y\": 2.5, \"type\": \"Key\", \"texture_name\": \"Key\", \"texture_index\": 0, \"is_active\": True, \"scale\": 0.5},\n     # \"entity_chest_1\": {\"id\": \"entity_chest_1\", \"x\": 8.5, \"y\": 1.5, \"type\": \"Chest\", \"texture_name\": \"Chest\", \"texture_index\": 0, \"is_active\": True, \"scale\": 0.8}\n}\n# ---------------------------\n\n\nclass ClientHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handles communication with a single client.\"\"\"\n    client_id: str = None\n    buffer: str = \"\" # Buffer for partial messages\n\n    def setup(self):\n        \"\"\"Called when a new client connects.\"\"\"\n        self.client_id = str(uuid.uuid4()) # More robust ID\n        print(f\"Client connected: {self.client_address}, assigned ID: {self.client_id}\")\n\n        with server_state_lock:\n            connected_clients[self.client_id] = self\n            # Initialize player state (client will send its actual starting state)\n            # Use the actual player start coordinates from config/defaults\n            player_states[self.client_id] = {\n                \"x\": player_start_x, \"y\": player_start_y, \"angle\": player_start_angle,\n                \"health\": config.PLAYER_HEALTH_START if 'config' in globals() else 100,\n                \"is_shooting\": False, \"is_dead\": False, \"is_running\": False\n            }\n\n        # 1. Send handshake acknowledgment with the client's new ID\n        handshake_msg = {\"type\": \"handshake_ack\", \"payload\": {\"client_id\": self.client_id}}\n        self.send_message(handshake_msg)\n\n        # 2. Send the initial full game state\n        full_state = self.get_full_game_state()\n        initial_state_msg = {\"type\": \"game_state_full\", \"payload\": full_state}\n        self.send_message(initial_state_msg)\n\n        # 3. Notify *other* clients about the new connection\n        new_player_update = {\n             \"players\": {self.client_id: player_states[self.client_id]} # Send initial actual state\n        }\n        broadcast_message({\"type\": \"game_state_update\", \"payload\": new_player_update}, exclude_client_id=self.client_id)\n\n\n    def handle(self):\n        \"\"\"Main loop to receive data from the client.\"\"\"\n        try:\n            while True:\n                data = self.request.recv(4096).decode('utf-8')\n                if not data:\n                    print(f\"Client {self.client_id} disconnected (no data).\")\n                    break\n\n                self.buffer += data\n                while '\\n' in self.buffer:\n                    message_str, self.buffer = self.buffer.split('\\n', 1)\n                    if message_str:\n                        try:\n                            message = json.loads(message_str)\n                            self.process_message(message)\n                        except json.JSONDecodeError:\n                            print(f\"Warning: Received invalid JSON from {self.client_id}: {message_str}\")\n                        except Exception as e:\n                             print(f\"Error processing message from {self.client_id}: {e}\")\n\n        except ConnectionResetError:\n            print(f\"Client {self.client_id} connection reset.\")\n        except Exception as e:\n            print(f\"Error in handler for {self.client_id}: {e}\")\n        finally:\n            pass # Cleanup is handled in finish()\n\n\n    def finish(self):\n        \"\"\"Called when the client disconnects or handle() exits.\"\"\"\n        if not self.client_id: return # Avoid issues if setup failed partially\n        print(f\"Cleaning up connection for client {self.client_id} ({self.client_address}).\")\n        with server_state_lock:\n            if self.client_id in connected_clients:\n                del connected_clients[self.client_id]\n            if self.client_id in player_states:\n                del player_states[self.client_id]\n\n        disconnect_payload = {\"client_id\": self.client_id}\n        broadcast_message({\"type\": \"player_disconnect\", \"payload\": disconnect_payload}, exclude_client_id=self.client_id)\n\n\n    def process_message(self, message: Dict[str, Any]):\n        \"\"\"Handles specific message types from the client.\"\"\"\n        msg_type = message.get(\"type\")\n        payload = message.get(\"payload\")\n\n        if msg_type == \"player_update\" and payload:\n            with server_state_lock:\n                 if self.client_id in player_states:\n                    player_states[self.client_id].update(payload)\n                 else:\n                     player_states[self.client_id] = payload # Should not happen\n\n            update_payload = { \"players\": {self.client_id: payload} }\n            # --- TODO: Server side logic here ---\n            # Validate movement, check shooting hits, update health, NPC AI etc.\n            # For now, just relay the state.\n            # Example: Check if player shot the debug sprite\n            # if payload.get(\"is_shooting\"):\n            #    player_pos = (payload.get(\"x\"), payload.get(\"y\"))\n            #    player_angle = payload.get(\"angle\")\n            #    with server_state_lock: # Lock needed to access sprite_states potentially\n            #         hit_sprite_id = check_shot_hit(player_pos, player_angle, sprite_states)\n            #         if hit_sprite_id == \"sprite_guard_npc\":\n            #             print(\"Player shot the debug sprite!\")\n            #             # Modify sprite state (e.g., health) and include in update_payload\n            #             if \"sprites\" not in update_payload: update_payload[\"sprites\"] = {}\n            #             sprite_states[hit_sprite_id][\"health\"] -= 10\n            #             update_payload[\"sprites\"][hit_sprite_id] = {\"health\": sprite_states[hit_sprite_id][\"health\"]}\n\n\n            broadcast_message({\"type\": \"game_state_update\", \"payload\": update_payload}, exclude_client_id=self.client_id)\n\n        elif msg_type == \"request_map\":\n             map_msg = {\"type\": \"map_update\", \"payload\": game_map_data}\n             self.send_message(map_msg)\n        else:\n            print(f\"Warning: Received unhandled message type '{msg_type}' from {self.client_id}\")\n\n\n    def send_message(self, message: Dict[str, Any]):\n        \"\"\"Sends a JSON message to this specific client.\"\"\"\n        if not self.request._closed: # Check if socket is still open\n            try:\n                json_message = json.dumps(message) + '\\n'\n                self.request.sendall(json_message.encode('utf-8'))\n            except OSError as e:\n                print(f\"Error sending message to {self.client_id}: {e}\")\n            except Exception as e:\n                 print(f\"Error encoding or sending message to {self.client_id}: {e}\")\n\n\n    def get_full_game_state(self) -> Dict[str, Any]:\n        \"\"\"Constructs the complete current game state.\"\"\"\n        with server_state_lock:\n            # Create copies to avoid potential modification during iteration/sending\n            current_player_states = {pid: pdata.copy() for pid, pdata in player_states.items()}\n            current_sprite_states = {sid: sdata.copy() for sid, sdata in sprite_states.items()}\n            current_entity_states = {eid: edata.copy() for eid, edata in entity_states.items()}\n\n        return {\n            \"map\": game_map_data,\n            \"players\": current_player_states,\n            \"sprites\": current_sprite_states,\n            \"entities\": current_entity_states,\n        }\n\n\ndef broadcast_message(message: Dict[str, Any], exclude_client_id: Optional[str] = None):\n    \"\"\"Sends a message to all connected clients, optionally excluding one.\"\"\"\n    with server_state_lock:\n        client_ids = list(connected_clients.keys()) # Copy keys for safe iteration\n\n    for cid in client_ids:\n        if cid != exclude_client_id:\n            handler = None\n            with server_state_lock:\n                 handler = connected_clients.get(cid) # Get handler safely\n\n            if handler:\n                handler.send_message(message) # Handler method handles potential errors\n\n\nclass ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"A TCP server that handles each client in a separate thread.\"\"\"\n    daemon_threads = True\n    allow_reuse_address = True\n\n\nif __name__ == \"__main__\":\n    print(\"Starting Python Raycaster Test Server...\")\n    server = ThreadedTCPServer((SERVER_HOST, SERVER_PORT), ClientHandler)\n    print(f\"Server listening on {SERVER_HOST}:{SERVER_PORT}\")\n\n    try:\n        server.serve_forever()\n    except KeyboardInterrupt:\n        print(\"\\nServer shutting down by request...\")\n    finally:\n        server.shutdown()\n        server.server_close()\n        print(\"Server shutdown complete.\")"
    },
    {
      "filename": "sprite.py",
      "metadata": {
        "lines": 44,
        "modified": "2025-04-29T20:27:36.473164"
      },
      "content": "# sprite.py\n# Generic representation for server-controlled sprites (like enemies)\nimport math\nfrom typing import Optional, Tuple\nimport config\n\nclass Sprite:\n    def __init__(self, sprite_id: str, data: dict):\n        self.id = sprite_id\n        self.x: float = 0.0\n        self.y: float = 0.0\n        self.texture_name: str = \"Unknown\" # e.g., \"EnemyTypeA\", \"Barrel\"\n        self.texture_index: int = 0 # Specific frame/variant\n        self.health: Optional[int] = None # If applicable\n        self.is_shooting: Optional[bool] = None # If applicable\n        self.is_dead: Optional[bool] = None # If applicable\n        self.scale: float = config.SPRITE_SCALE\n        self.last_update_time: float = 0.0\n\n        self.update_from_server(data)\n\n    def update_from_server(self, data: dict):\n        \"\"\"Updates sprite state from server data.\"\"\"\n        self.x = data.get(\"x\", self.x)\n        self.y = data.get(\"y\", self.y)\n        self.texture_name = data.get(\"texture_name\", self.texture_name)\n        self.texture_index = data.get(\"texture_index\", self.texture_index) # Server decides animation frame etc.\n        self.health = data.get(\"health\", self.health)\n        self.is_shooting = data.get(\"is_shooting\", self.is_shooting)\n        self.is_dead = data.get(\"is_dead\", self.is_dead)\n        self.scale = data.get(\"scale\", self.scale)\n        # self.last_update_time = pr.get_time()\n\n    def get_pos_tuple(self) -> Tuple[float, float]:\n        return (self.x, self.y)\n\n    def should_draw(self) -> bool:\n        \"\"\"Determines if the sprite should be drawn (e.g., not dead and collected).\"\"\"\n        # Add logic here based on state, e.g.\n        # if self.is_dead and self.texture_name != \"Corpse\": return False\n        # For now, draw everything unless explicitly told 'is_dead' is True\n        # and we decide dead sprites shouldn't render (or use a dead texture index)\n        # return not self.is_dead if self.is_dead is not None else True\n        return True # Draw all sprites for now"
    }
  ]
}